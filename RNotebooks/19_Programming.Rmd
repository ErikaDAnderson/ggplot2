---
title: "ggplot2: 19 Programming with ggplot2"
output: html_notebook
---

This notebook is based on exercises completed from [ggplot2: Elegant Graphics for Data Analysis](https://ggplot2-book.org/index.html). 

```{r setup, warning=FALSE,message=FALSE}
library(tidyverse)

# set theme for all plots
theme_set(theme_bw())

```

## 19.2.1 Single Component Exercises

1.Create an object that represents a pink histogram with 100 bins.

```{r}

hist_fn <- function(bins = 100, fill = "pink", ...)  {
  
  geom_histogram(bins = 100, fill = "pink", ...)
}

ggplot(diamonds, aes(carat)) + 
  hist_fn()

```


2.Create an object that represents a fill scale with the Blues ColorBrewer palette.

```{r}

myPalette <- scale_fill_brewer(palette = "Blues")

ggplot(mpg, aes(manufacturer, fill = class)) + 
  geom_bar() +
  myPalette +
  coord_flip() 

```


3.Read the source code for theme_grey(). What are its arguments? How does it work?

The signature ggplot2 theme with a grey background and white gridlines, designed to put the data forward yet make comparisons easy. Read more about ggplot themes online including [theme_grey source code](http://applied-r.com/themes-ggplot/)


```{r}

# theme_grey()
theme_grey <- function (base_size = 12, base_family = "") {
   require(grid)
   theme(line = element_line(colour = "black", size = 0.5, linetype = 1, lineend = "butt"),
   rect = element_rect(fill = "white", colour = "black", size = 0.5, linetype = 1),
   text = element_text(family = base_family,face = "plain", colour = "black",
   size = base_size, hjust = 0.5, vjust = 0.5, angle = 0, lineheight = 0.9),
   axis.text = element_text(size = rel(0.8), colour = "grey50"),
   strip.text = element_text(size = rel(0.8)),
   axis.line = element_blank(),
   axis.text.x = element_text(vjust = 1),
   axis.text.y = element_text(hjust = 1),
   axis.ticks = element_line(colour = "grey50"),
   axis.title.x = element_text(),
   axis.title.y = element_text(angle = 90),
   axis.ticks.length = unit(0.15, "cm"),
   axis.ticks.margin = unit(0.1, "cm"),
 
   legend.background = element_rect(colour = NA),
   legend.margin = unit(0.2, "cm"),
   legend.key = element_rect(fill = "grey95", colour = "white"),
   legend.key.size = unit(1.2, "lines"),
   legend.key.height = NULL,
   legend.key.width = NULL,
   legend.text = element_text(size = rel(0.8)),
   legend.text.align = NULL,
   legend.title = element_text(size = rel(0.8), face = "bold", hjust = 0),
   legend.title.align = NULL,
   legend.position = "right",
   legend.direction = NULL,
   legend.justification = "center",
   legend.box = NULL,
 
   panel.background = element_rect(fill = "grey90", colour = NA),
   panel.border = element_blank(),
   panel.grid.major = element_line(colour = "white"),
   panel.grid.minor = element_line(colour = "grey95", size = 0.25),
   panel.margin = unit(0.25, "lines"),
 
   strip.background = element_rect(fill = "grey80", colour = NA),
   strip.text.x = element_text(),
   strip.text.y = element_text(angle = -90),
 
   plot.background = element_rect(colour = "white"),
   plot.title = element_text(size = rel(1.2)),
   plot.margin = unit(c(1, 1, 0.5, 0.5), "lines"), complete = TRUE)
}


```


4.Create scale_colour_wesanderson(). It should have a parameter to pick the palette from the wesanderson package, and create either a continuous or discrete scale.

```{r}

 scale_colour_wesanderson <- function(..., mynumber, myname, mytype) {
   
   require(wesanderson)
   
  scale_color_manual(values = wes_palette(mynumber, name = myname, type = mytype), name = "")
 
 }

ggplot(mpg, aes(hwy, cty, color = class)) +
  geom_point() +
  scale_colour_wesanderson(mynumber = 7, 
                           myname = "GrandBudapest1", 
                           mytype = "continuous")

# or use less for discrete example
mpg %>%
  filter(class %in% c("2seater", "compact", "midsize", "pickup", "suv")) %>%
  ggplot(aes(hwy, cty, color = class)) +
  geom_point() +
  scale_colour_wesanderson(mynumber = 5, 
                           myname = "Zissou1", 
                           mytype = "discrete")


```


## 19.3.4 Multiple Component Exercises

1.To make the best use of space, many examples in this book hide the axes labels and legend. I’ve just copied-and-pasted the same code into multiple places, but it would make more sense to create a reusable function. What would that function look like?

```{r}

removeAxes_fn <- function(...) {
  
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        legend.position = "none")
  
}

ggplot(mpg, aes(cty, hwy, color = class)) +
  geom_point() +
  removeAxes_fn()
  
# can anyone see where NAs coming from?

```


2.Extend the borders() function to also add coord_quickmap() to the plot.

```{r}

borders <- function(database = "world", regions = ".", fill = NA, 
                    colour = "grey50", ...) {
  df <- map_data(database, regions)
  list(geom_polygon(
    aes_(~lat, ~long, group = ~group), 
    data = df, fill = fill, colour = colour, ..., 
    inherit.aes = FALSE, show.legend = FALSE),
    # asked for coord_quickmap but looks sideways
    #coord_quickmap() 
     #,
    # so I choose flip instead 
    coord_flip())
}


ggplot() +
  borders()

```


3.Look through your own code. What combinations of geoms or scales do you use all the time? How could you extract the pattern into a reusable function?

I often make font bigger on axis titles and text


```{r}

biggerfont <- theme(
        axis.title = element_text(size = 16),
        axis.text =  element_text(size = 14))

ggplot(mpg, aes(drv, cty)) +
  geom_point() 

ggplot(mpg, aes(drv, cty)) +
  geom_point() +
  biggerfont

# Is there any advantage to using function versus object?

```

## 19.4.3 Exercises

1. Create a distribution() function specially designed for visualising continuous distributions. Allow the user to supply a dataset and the name of a variable to visualise. Let them choose between histograms, frequency polygons, and density plots. What other arguments might you want to include?

2. What additional arguments should pcp() take? What are the downsides of how ... is used in the current code?

3. Advanced: why doesn’t this code work? How can you fix it?

```{r}

f <- function() {
  levs <- c("2seater", "compact", "midsize", "minivan", "pickup", 
    "subcompact", "suv")
  piechart3(mpg, factor(class, levels = levs))
}
f()

#> Error in factor(class, levels = levs): object 'levs' not found
```

## 19.5.1 Exercises

1. How could you add a geom_point() layer to each element of the following list?

```{r}
plots <- list(
  ggplot(mpg, aes(displ, hwy)),
  ggplot(diamonds, aes(carat, price)),
  ggplot(faithfuld, aes(waiting, eruptions, size = density))
)
```

2. What does the following function do? What’s a better name for it?

displays each step of ggplot between each +
I would call it layersFn

```{r}
mystery <- function(...) {
  Reduce(`+`, list(...), accumulate = TRUE)
}

mystery(
  ggplot(mpg, aes(displ, hwy)) + geom_point(), 
  geom_smooth(), 
  xlab(NULL), 
  ylab(NULL)
)
```


